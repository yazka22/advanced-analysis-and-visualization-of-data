# -*- coding: utf-8 -*-
"""Proiect_Vizualizare.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XRYRkgcFFfJGcFfQP9kNGmNun04x06x_
"""

# Commented out IPython magic to ensure Python compatibility.
#importam librariele necesare
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
import warnings
import itertools
warnings.filterwarnings(action='ignore')
import plotly.express as px
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima_model import ARIMA
from pylab import rcParams
import statsmodels.api as sm

from google.colab import files
data = files.upload()#incarcarea datelor

import io#citirea a datelor
df = pd.read_excel(io.BytesIO(data['Sales.xls']))

df.head()#arata cele 5 randuri inceput de la date

df.tail() #arata cele 5 randuri in sfarsit de la date

df.shape #comanda returnează un tuplu reprezentând dimensiunile unui DataFrame în format

df.info()#pentru a afisa informatii despre dataset

df.describe()# pentru a genera statistici descriptive ale coloanelor numerice ale unui DataFrame

df.columns #toate coloanele

"""Preprocesarea datelor.Gestionarea valorilor lipsă"""

df.isnull().sum() #returnează numărul de valori lipsă în fiecare coloană a unui DataFrame.Nu avem nicio valoare lipsa

df=df.dropna(axis=0)

df.isnull().sum()

df.shape # new shape

"""Correlatia Si Heatmap

"""

corrmat=df.corr()
top_corr=corrmat.index
plt.figure(figsize=(15,15))
#plot heatmap
g=sns.heatmap(df[top_corr].corr(),annot=True,cmap='RdYlGn')

"""Din Heatmap putem vedea că Profit, Discount au cea mai mică corelație"""

df.drop(['Row ID','Ship Date','Ship Mode','Customer ID','Postal Code','Order ID','Profit','Discount'],axis=1,inplace=True)

df.to_csv('train1.csv')

print(df.shape)
df.head()

"""Întrebări de analiză:
ce stat din SUA are o frecvență mai mare de vânzări?
in ce an am avut vanzari maxime?
in ce luna avem vanzari maxime?
care zile ale lunii generează vânzări mai mari?
care sunt primele 10 state cu vânzări mari?
care sunt primele 20 de orașe cu vânzări mari?
produse de top foarte solicitate?
Cei mai frecventi clienti?
"""

df['Country'].unique()# Determinarea categoriilor din coloana Country de la DataFrame

"""Am descoperit că înregistrările sunt în întregime ale Statelor Unite."""

states=df['State'].unique()
np.count_nonzero(states)

cities=df['City'].unique()
np.count_nonzero(cities)

top_cities= df['City'].value_counts().nlargest(20)
top_cities

"""New York are cele mai mari vânzări din toată SUA"""

top_customers= df['Customer Name'].value_counts().nlargest(20)
top_customers

"""William Brown este cel mai frecvent client aici. Să explorăm mai multe despre William Brown!!"""

rslt_df = df[df['Customer Name'] == 'William Brown'] 
rslt_df.head()

category=df['Category'].unique()
print(category)
print(np.count_nonzero(category))

"""Există 3 categorii de produse în Supermarket- Furnutire, Office Supplies, Technology

"""

plt.rcParams['figure.figsize'] = (10, 8)
sns.barplot(x = df['Category'], y = df['Sales'], palette ='dark')
plt.title('The Distribution of Sales in each Category', fontsize = 10)
plt.xlabel('Category', fontsize = 15)
plt.ylabel('Count', fontsize = 15)

subcategory=df['Sub-Category'].unique()
print(subcategory)
print(np.count_nonzero(subcategory))

plt.rcParams['figure.figsize'] = (19, 8)
sns.barplot(x = df['Sub-Category'], y = df['Sales'], palette ='dark')
plt.title('The Distribution of Sales in each Sub-Category', fontsize = 30)
plt.xlabel('Sub-Category', fontsize = 15)
plt.ylabel('Count', fontsize = 15)

top_products= df['Sub-Category'].value_counts().nlargest(5)
top_products

segment=df['Segment'].unique()
print(segment)
print(np.count_nonzero(segment))

#vizualizarea distribuției pe segmente a vânzărilor
plt.rcParams['figure.figsize'] = (19, 8)
sns.barplot(x = df['Segment'], y = df['Sales'], palette ='dark')
plt.title('The Distribution of Sales in each Segment', fontsize = 30)
plt.xlabel('Segment', fontsize = 15)
plt.ylabel('Count', fontsize = 15)

#vizualizarea distribuției vânzărilor la nivel de stat
df.groupby(['State'])['Sales'].nunique().plot.bar(figsize = (19, 7), cmap= 'rainbow')
plt.gcf().autofmt_xdate()
plt.title('Comparing statewise sales frequency', fontsize = 30)
plt.xlabel('States in US', fontsize = 10)
plt.ylabel('Sales Frequency')
plt.show()

top_states= df['State'].value_counts().nlargest(10)
top_states

print(df['State'].max())#California are vânzări de înaltă frecvență, în timp ce Wyoming are prețul total de vânzare maxim.

"""Distribuția totală a vânzărilor"""

plt.rcParams['figure.figsize'] = (15, 8)
sns.distplot(df['Sales'], color = 'red')
plt.title('The Distribution of Sales', fontsize = 30)
plt.xlabel('Range of Sales', fontsize = 15)
plt.ylabel('No. of Sales count', fontsize = 15)
plt.show()

df['Order Date'] = pd.to_datetime(df['Order Date'], errors = 'coerce') # era deja obiect datetime înainte, nu un pas necesar

#extragerea Year out of the Date pentru a face o analiză anuală
df['Year'] = df['Order Date'].dt.year

#extragerea Month din Data pentru a face o analiză lunară
df['Month'] = df['Order Date'].dt.month

df['Date'] = df['Order Date'].dt.day

df.columns

# separarea caracteristicilor dependente de cele independente
X=df.copy()
X.drop(['Sales'],axis=1,inplace=True)
X.head() # caracteristici independente

y=df.iloc[:,11] # țintă, precum și caracteristică dependentă
y.head()

plt.rcParams['figure.figsize'] = (19, 8)
sns.boxplot(x = df['Year'], y = df['Sales'], palette ='dark')
plt.title('The Distribution of Sales in each Year', fontsize = 30)
plt.xlabel('Year', fontsize = 15)
plt.ylabel('Sales Price', fontsize = 15)

year_max=df[df['Sales'] == 22638.480000] 
year_max

#vizualizarea distribuției lunare a vânzărilor
plt.rcParams['figure.figsize'] = (19, 8)
sns.barplot(x = df['Month'], y = df['Sales'], palette ='pastel')
plt.title('The Distribution of Sales in each month', fontsize = 30)
plt.xlabel('Months', fontsize = 15)
plt.ylabel('Sales', fontsize = 15)

plt.rcParams['figure.figsize'] = (19, 8)
sns.barplot(x = df['Date'], y = df['Sales'], palette ='colorblind')
plt.title('The Distribution of Sales in each day', fontsize = 30)
plt.xlabel('Days', fontsize = 15)
plt.ylabel('Sales', fontsize = 15)

"""Distribuția vânzărilor pe parcursul lunii continuă să varieze; Se observă că cea mai mare este în mare parte la mijlocul lunii.

Analiza serii de timp a vânzărilor și a datei comenzii
"""

#extragerea lor într-un cadru de date separat
features=['Order Date','Sales']
salesplot=df[features]
salesplot.head()

"""Datele de comandă nu sunt în ordine sortată, prin urmare sortarea cadrului de date în funcție de dată"""

salesplot.sort_values(by='Order Date',inplace=True)
salesplot

Order_date=salesplot['Order Date']
Sales=salesplot['Sales']

plt.plot_date(Order_date,Sales,xdate=True)
plt.gcf().autofmt_xdate()
plt.title('Sales Data')
plt.xlabel('Order Date')
plt.ylabel('Sales')

"""Deoarece axa X nu va afișa toate datele, este mai bine să utilizați un grafic interactiv, cum ar fi Rangeslider"""

import plotly.express as px

fig = px.line(salesplot, x=Order_date, y=Sales, title='Time Series with Rangeslider')

fig.update_xaxes(rangeslider_visible=True)
fig.show()

"""Serii de timp cu ARIMA"""

df1=pd.read_csv('train1.csv')
df1.head()

df1.shape

#pentru prognoza vânzărilor avem nevoie doar de Data comenzii și coloana Vânzări a trenului 1.csv
features=['Order Date','Sales']
dfs=df1[features]
dfs.head()

dfs.shape

dfs.info()

dfs.tail()

dfs['Order Date'] = pd.to_datetime(dfs['Order Date'], errors = 'coerce')
dfs.info()

#setare index
dfs=dfs.groupby('Order Date')['Sales'].sum().reset_index()

dfs

dfs=dfs.set_index('Order Date')
dfs.index

#folosind începutul fiecărei luni ca marca temporală
y=dfs['Sales'].resample('MS').mean()

y['2015':]

y.plot(figsize=(15,6))
plt.show()

"""Modelul arată că vânzările generale scad la începutul anului. De asemenea, rata de creștere a vânzărilor a crescut în cele din urmă din 2014 până în 2018.

Vizualizarea Tendințelor, precum și a sezonului în datele din seria timp
"""

rcParams['figure.figsize']=19,9

decomp=sm.tsa.seasonal_decompose(y,model='additive')
fig=decomp.plot()
plt.show()

"""Primul grafic este cel OBSERVAT, care este graficul pe care l-am văzut în celula anterioară. Al doilea, arată tendința datelor de vânzări care cresc de la scăzut la mai mare pe parcursul a 3 ani. Sezonalitatea și graficul rezidual arată că vânzările sunt destul de instabile și trebuie să fie mărite pentru prognoze ulterioare"""

p=d=q=range(0,2)
pdq=list(itertools.product(p,d,q))
seas_pdq=[(x[0],x[1],x[2],12) for x in list(itertools.product(p,d,q))]

print('Some of the parameter combinations for Seasonal ARIMA:-')
print('SARIMAX: {} x {}'.format(pdq[1], seas_pdq[1]))
print('SARIMAX: {} x {}'.format(pdq[1], seas_pdq[2]))
print('SARIMAX: {} x {}'.format(pdq[2], seas_pdq[3]))
print('SARIMAX: {} x {}'.format(pdq[2], seas_pdq[4]))

#folosind Grid Search pentru a găsi setul optim de parametri care oferă cea mai bună performanță pentru modelul nostru
#selectarea parametrilor pentru modelul nostru
for param in pdq:
    for param_seasonal in seas_pdq:
        try:
            mod=sm.tsa.statespace.SARIMAX(y,order=param, seasonal_order=param_seasonal, enforce_stationarity=False, enforce_invertibility=False)
            results=mod.fit()
            print('ARIMA{}x{}12 - AIC:{}'.format(param,param_seasonal,results.aic))
        except:
            continue

"""Folosirea modelul ARIMA"""

mod=sm.tsa.statespace.SARIMAX(y,order=(1,1,1),seasonal_order=(1,1,1,12), enforce_invertibility=False)
results=mod.fit()
print(results.summary().tables[1])

results.plot_diagnostics(figsize=(15, 12))
plt.show()

"""Statisticile de mai sus sugerează că reziduurile modelului nostru sunt distribuite aproximativ normal

Validarerea Modelului
"""

pred = results.get_prediction(start=pd.to_datetime('2017-01-01'), dynamic=False)
pred_ci = pred.conf_int()
ax = y['2014':].plot(label='observed')
pred.predicted_mean.plot(ax=ax, label='One-step ahead Forecast', alpha=.7, figsize=(14, 7))
ax.fill_between(pred_ci.index,
                pred_ci.iloc[:, 0],
                pred_ci.iloc[:, 1], color='k', alpha=.2)
ax.set_xlabel('Date')
ax.set_ylabel('Product Sales')
plt.legend()
plt.show()

"""Graficul de mai sus compară previziunile observate cu cele prognozate în zona gri și se dovedește a fi destul de aproximativă.

Calcularea MSE si RMSE pentru modelul nostru
"""

y_forecasted = pred.predicted_mean
y_truth = y['2017-01-01':]

# mse
mse = ((y_forecasted - y_truth) ** 2).mean()
print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))

# rmse
print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))

"""Mse și Rmse se dovedesc a nu fi atât de bune, deoarece aici analizăm vânzările generale și nu pe categorii de produse. Dar din analiza și validarea generală, modelul funcționează destul de bine"""

#Aceasta arată previziunile pentru următorii câțiva ani
pred_uc1 = results.get_forecast(steps=100)
pred_ci1 = pred_uc1.conf_int()
ax = y.plot(label='observed', figsize=(14, 7))
pred_uc1.predicted_mean.plot(ax=ax, label='Forecast')
ax.fill_between(pred_ci1.index,
                pred_ci1.iloc[:, 0],
                pred_ci1.iloc[:, 1], color='k', alpha=.25)
ax.set_xlabel('Date')
ax.set_ylabel('Furniture Sales')
plt.legend()
plt.show()

#Aceasta arată previziunile pentru următorii 7 zile
pred_uc = results.get_forecast(steps=7)
pred_ci = pred_uc.conf_int()
ax = y.plot(label='observed', figsize=(14, 7))
pred_uc.predicted_mean.plot(ax=ax, label='Forecast')
ax.fill_between(pred_ci.index,
                pred_ci.iloc[:, 0],
                pred_ci.iloc[:, 1], color='k', alpha=.25)
ax.set_xlabel('Date')
ax.set_ylabel('Product Sales')
plt.title('Weekly sales forecast', fontsize=12)
plt.legend()
plt.show()

"""Tabel final cu prognoza vânzărilor pe 7 zile"""

predicted_sale= pred_ci1[:7]

predicted_sale

predicted_sale.to_csv('weeklyoutput_forecast.csv')

"""Acesta este tabelul final de producție pentru vânzările prognozate în următoarele 7 zile și arată că va exista o creștere moderată a ratei de vânzări în următoarele 7 zile.

Construirea tabelului de Sales confirmate și prognozate din care am calculat MSE și RMSE
"""

y_truth.head()

y_forecasted.head()

output = pd.concat([y_truth, y_forecasted], axis=1)

output.head()